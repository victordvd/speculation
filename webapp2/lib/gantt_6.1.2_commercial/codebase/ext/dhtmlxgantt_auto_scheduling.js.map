{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./sources/core/relations/links_builder.js","webpack:///./sources/ext/auto_scheduling/constraint_types.ts","webpack:///./sources/core/relations/graph_helper.js","webpack:///./sources/core/relations/links_common.js","webpack:///./sources/ext/auto_scheduling/ui_handlers.ts","webpack:///./sources/ext/auto_scheduling/loops_finder.ts","webpack:///./sources/ext/auto_scheduling/connected_groups.ts","webpack:///./sources/ext/auto_scheduling/asap_strategy.ts","webpack:///./sources/ext/auto_scheduling/alap_strategy.ts","webpack:///./sources/ext/auto_scheduling/planner.ts","webpack:///./sources/ext/auto_scheduling/constraints.ts","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js","webpack:///./sources/ext/auto_scheduling/task_plan.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","this","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","undefined","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","ConstraintTypes","helpers","getVertices","ids","len","source","vertices","topologicalSort","edges","hash","$incoming","successor","S","filter","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","w","Math","min","com","tasks","links","findLoops","cycles","forEach","component","_get_linked_task","link","getTarget","task","taskId","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_formatLink","isSummaryTask","isChildOf","_getImplicitLinks","respectTargetOffset","auto_scheduling_move_projects","targetDates","start_date","end_date","to","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","eachTask","linksCollection","siblingLink","getLink","siblingId","siblingTask","abs","duration","_getDirectDependencies","selectSuccessors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","eachParent","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","sourceTask","targetTask","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","_autoScheduleAfterLinkChange","_autoscheduling_in_progress","autoSchedule","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","movedTask","attachEvent","auto_scheduling_initial","_autoScheduleAfterDND","newTask","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","relationsArray","skipped","originalLink","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","auto_scheduling_strict","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","findCycles","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","map","task_plan_1","AsapStrategy","Create","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","TaskPlan","kind","earliestSchedulingStart","earliestSchedulingEnd","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","plan","predecessorEnd","successorStart","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","latestSchedulingStart","latestSchedulingEnd","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","earliestStart","earliestEnd","latestStart","latestEnd","conflict","slice","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate","units","second","minute","hour","day","week","month","quarter","year","arrayFilter","arr","callback","getSecondsInUnit","unit","workArray","arrayMap","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","sortArrayOfHash","field","desc","compare","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","obj","Array","isDate","getFullYear","getMonth","getDate","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 242);\n","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = task.id + skipInherited;\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\t\t\tnewTask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\t\t\tnewTask.constraint_date = new Date(newTask.end_date);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewTask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\t\t\tnewTask.constraint_date = new Date(newTask.start_date);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO: remove in 7.0\n\t\t\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\t\t\tif (newTask.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\t\t\tnewTask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\t\tnewTask.constraint_type = null;\n\t\t\t\t\t\t\tnewTask.constraint_date = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date);\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys\n};","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}"],"sourceRoot":""}